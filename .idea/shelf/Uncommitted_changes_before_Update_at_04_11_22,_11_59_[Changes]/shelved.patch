Index: Progetto_Nuovo/Data/StatsManager.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from scipy.stats import beta\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom itertools import chain\n\n\ndef evaluate_mean_std_rewards(rewards):\n  mean = np.mean(rewards, axis=0)\n  std = np.std(rewards, axis=0)\n  plt.figure(figsize=(9, 6))\n  plt.plot(range(len(mean)), mean)\n  plt.fill_between(range(len(mean)), (mean - std), (mean + std), color='b', alpha=.1)\n  plt.show()\n  return mean, std\n\n\ndef printRegret(rewards, clairvoyant):\n  plt.figure(figsize=(9, 6))\n  plt.ylabel(\"Regret\")\n  plt.xlabel(\"t\")\n  plt.plot(np.cumsum(np.mean(clairvoyant - rewards, axis=0)), color='g', label='Regret')\n  plt.legend()\n  plt.grid()\n  plt.show()\n\n\ndef printReward(rewards, clairvoyant):\n  mean = np.mean(rewards, axis=0)\n  std = np.std(rewards, axis=0)\n  plt.figure(figsize=(9, 6))\n  plt.xlabel(\"t\")\n  plt.ylabel(\"Reward\")\n  # TODO: ERRORE NEL PLOT DEL CLAIRVOYANT\n  #plt.axhline(y=clairvoyant, color='r', linestyle='-', label='Clairvoyant')\n  plt.plot(mean, color='b', label='Reward')\n  plt.fill_between(range(len(mean)), (mean - std), (mean + std), color='b', alpha=.1)\n  plt.grid()\n  plt.show()\n\n\n\ndef printTSBeta(beta_parameters, exp_reward):\n  plt.figure(figsize=(16, 9))\n  x = np.linspace(0, 1, 1000)\n  colors = ['red', 'green', 'blue', 'purple', 'orange']\n  for params, rew, color in zip(beta_parameters, exp_reward, colors):\n    rv = beta(*params)\n    plt.plot(x, rv.pdf(x), color=color)\n    #plt.axvline(rew, linestyle='--', color=color)\n  plt.grid()\n  plt.show()\n\ndef printUCBBound(regrets, pseudo_regrets, T, n_repetitions, deltas):\n  # Compute the cumulative sum\n  cumu_regret = np.cumsum(regrets, axis=1)\n  cumu_pseudo_regret = np.cumsum(pseudo_regrets, axis=1)\n\n  # Take the average over different runs\n  avg_cumu_regret = np.mean(cumu_regret, axis=0)\n  avg_cumu_pseudo_regret = np.mean(cumu_pseudo_regret, axis=0)\n\n  std_cumu_regret = np.std(cumu_regret, axis=0)\n  std_cumu_pseudo_regret = np.std(cumu_pseudo_regret, axis=0)\n\n  ucb1_upper_bound = np.array([8 * np.log(t) * sum(1 / deltas) + (1 + np.pi ** 2 / 3) * sum(deltas)\n                               for t in range(1, T + 1)])\n\n  plt.figure(figsize=(16, 9))\n  plt.ylabel(\"Regret\")\n  plt.xlabel(\"t\")\n  plt.plot(avg_cumu_pseudo_regret, color='r', label='Pseudo-regret')\n  plt.plot(avg_cumu_regret + 1.96 * std_cumu_regret / np.sqrt(n_repetitions), linestyle='--', color='g')\n  plt.plot(avg_cumu_regret, color='g', label='Regret')\n  plt.plot(avg_cumu_regret - 1.96 * std_cumu_regret / np.sqrt(n_repetitions), linestyle='--', color='g')\n  plt.plot(ucb1_upper_bound, color='b', label='Upper bound')\n\n  plt.legend()\n  plt.grid()\n  plt.show()\n\n\ndef printData(price_configurations, customers, prices, number_of_customer_classes):\n  # print all the prices\n  print('All the available prices are: \\n{0}'.format(prices))\n  # print all the price configurations\n  print('\\nAll the available configurations are: ')\n  for config in price_configurations:\n    print(config)\n  print('\\nAll the reservation prices are: ')\n  for c in range(number_of_customer_classes):\n    print(customers[c].reservation_prices)\n'''\ndef print_conversion_rates(prices, products, conversion_rates):\n  x = prices  # list of prices\n  categories = categories  # list of categories\n\n  plt.figure(figsize=(14, 8))\n  for i in range(len(categories)):\n    y = env.probabilities[i]\n    smooth = interp1d(x, y, kind='cubic')\n    plt.plot(x, smooth(x), color=colors[i], label=aux_dict[i])\n    plt.scatter(x, y, color=colors[i])\n    plt.title(\"Conversion Rates\")\n    plt.xlabel(\"Price (â‚¬)\")\n    plt.ylabel(\"Conversion Rate\")\n\n  plt.legend()\n  plt.show()\n'''\n\n\ndef print_contextual_graphs(rewards_per_experiment, clairvoyant):\n    rewards = []\n    for exp_rewards in rewards_per_experiment:\n        rewards.append(list(chain(*exp_rewards)))\n        print(len(list(chain(*exp_rewards))))\n    for customer_class in range(3):\n        printReward(rewards, clairvoyant[customer_class])\n        printRegret(np.asarray(rewards), clairvoyant[customer_class])\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Progetto_Nuovo/Data/StatsManager.py b/Progetto_Nuovo/Data/StatsManager.py
--- a/Progetto_Nuovo/Data/StatsManager.py	(revision 738320252a715d0eaf18efc2c13aa63ffb0668ea)
+++ b/Progetto_Nuovo/Data/StatsManager.py	(date 1667558987471)
@@ -31,7 +31,7 @@
   plt.xlabel("t")
   plt.ylabel("Reward")
   # TODO: ERRORE NEL PLOT DEL CLAIRVOYANT
-  #plt.axhline(y=clairvoyant, color='r', linestyle='-', label='Clairvoyant')
+  plt.axhline(y=clairvoyant, color='r', linestyle='-', label='Clairvoyant')
   plt.plot(mean, color='b', label='Reward')
   plt.fill_between(range(len(mean)), (mean - std), (mean + std), color='b', alpha=.1)
   plt.grid()
Index: Progetto_Nuovo/Data/DataManager.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import json\n\nimport numpy as np\n\nfrom Progetto_Nuovo.Data_Structures.CustomerClass import *\n\n\ndef get_customer_class_from_json(filename):\n    file = open(filename)\n    data = json.load(file)\n    customer_class = CustomerClass()\n    customer_class.number_of_customers = data[\"n_users\"]\n    customer_class.alpha_probabilities = data[\"average_alphas\"]\n    customer_class.reservation_prices = data[\"reservation_prices\"]\n    customer_class.graph_probabilities = data[\"graph_probabilities\"]\n    customer_class.item_sold_mean = data[\"average_items_sold\"]\n    customer_class.conversion_rates = data[\"conversion_rates\"]\n    return customer_class\n\n\ndef get_json_from_binary_feature(binary_feature):\n    if binary_feature == [0, 0]:\n        return 0\n    elif binary_feature == [1, 0] or binary_feature == [0, 1]:\n        return 1\n    elif binary_feature == [1, 1]:\n        return 2\n    elif binary_feature == [-1, -1]:\n        return 3\n    elif binary_feature == [0, -1]:\n        return 4\n    return 5\n\n\ndef evaluate_rewards_per_combination(configurations, customer_class, prices):\n    rewards_per_combination = []\n    for i in range(len(configurations)):\n        current_reward = 0.\n        for product in range(5):\n            for price in range(4):\n                current_reward += prices[product][price] * customer_class.conversion_rates[product][price] * \\\n                                  customer_class.alpha_probabilities[product] * \\\n                                  customer_class.item_sold_mean[product][price]\n        rewards_per_combination.append(current_reward)\n    return max(rewards_per_combination)\n\n\ndef evaluate_contextual_clairvoyant(configurations, customer_classes, prices):\n    rewards_per_customer_class = []\n    for customer_class in customer_classes:\n        rewards_per_customer_class.append(evaluate_rewards_per_combination(configurations, customer_class, prices))\n    return rewards_per_customer_class\n\n\ndef evaluate_clairvoyant(configurations, max_units_sold, reservation_prices, n_users):\n    max_reward = 0.\n    for config in configurations:\n        opt_reward = 0.\n        # for each product\n        for product in range(5):\n            if reservation_prices[product] >= config[product]:\n                # evaluate the reward for\n                opt_reward += max_units_sold * n_users * config[product]\n        # average reward over all the simulations\n        opt_reward = opt_reward / n_users\n        if opt_reward > max_reward:\n            max_reward = opt_reward\n    return max_reward\n\n\ndef evaluate_abrupt_changes_clairvoyant(configurations, max_units_sold, reservation_prices, n_users, n_phases):\n    max_reward = np.zeros(n_phases)\n    for phase in range(n_phases):\n        for config in configurations:\n            opt_reward = 0.\n            # for each product\n            for product in range(5):\n                if reservation_prices[phase][product] >= config[product]:\n                    # evaluate the reward for\n                    opt_reward += max_units_sold * n_users * config[product]\n            # average reward over all the simulations\n            opt_reward = opt_reward / n_users\n            if opt_reward > max_reward[phase]:\n                max_reward[phase] = opt_reward\n    return max_reward\n\n\ndef get_customer_class_from_json_aggregate(file_name_class_1, file_name_class_2, file_name_class_3):\n    # Load file customer class non aggregate\n    file_class_1 = open(file_name_class_1)\n    file_class_2 = open(file_name_class_2)\n    file_class_3 = open(file_name_class_3)\n\n    # Extract data from JSON for user class\n    data_class_1 = json.load(file_class_1)\n    data_class_2 = json.load(file_class_2)\n    data_class_3 = json.load(file_class_3)\n\n    # Assign aggregate values tu agg customer class\n    customer_class_aggregate = CustomerClass()\n    # Agg number of customers\n    customer_class_aggregate.number_of_customers = data_class_1['n_users'] + data_class_2['n_users'] + data_class_3['n_users']\n    # Agg average alphas\n    temp_matrix = data_class_1['n_users'] * np.asarray(data_class_1['average_alphas']) + data_class_2['n_users'] * np.asarray(data_class_2['average_alphas']) + data_class_3['n_users'] * np.asarray(data_class_3['average_alphas'])\n    customer_class_aggregate.alpha_probabilities = np.asarray(temp_matrix) / customer_class_aggregate.number_of_customers\n    # Agg reservation prices\n    temp_matrix = (data_class_1['n_users'] * np.asarray(data_class_1['reservation_prices'])) + (data_class_2['n_users'] * np.asarray(data_class_2['reservation_prices'])) + (data_class_3['n_users'] * np.asarray(data_class_3['reservation_prices']))\n    customer_class_aggregate.reservation_prices = np.asarray(temp_matrix) / customer_class_aggregate.number_of_customers\n    # Agg graph probabilities\n    temp_matrix = data_class_1['n_users'] * np.asarray(data_class_1['graph_probabilities']) + data_class_2['n_users'] * np.asarray(data_class_2['graph_probabilities']) + data_class_3['n_users'] * np.asarray(data_class_3['graph_probabilities'])\n    customer_class_aggregate.graph_probabilities = np.asarray(temp_matrix) / customer_class_aggregate.number_of_customers\n    # Agg average item sold\n    temp_matrix = data_class_1['n_users'] * np.asarray(data_class_1['average_items_sold']) + data_class_2['n_users'] * np.asarray(data_class_2['average_items_sold']) + data_class_3['n_users'] * np.asarray(data_class_3['average_items_sold'])\n    customer_class_aggregate.item_sold_mean = np.asarray(temp_matrix) / customer_class_aggregate.number_of_customers\n    return customer_class_aggregate\n\n\ndef get_customer_class_from_json_aggregate_unknown_graph(file_name_class_1, file_name_class_2, file_name_class_3):\n    # Load file customer class non aggregate\n    file_class_1 = open(file_name_class_1)\n    file_class_2 = open(file_name_class_2)\n    file_class_3 = open(file_name_class_3)\n\n    # Extract data from JSON for user class\n    data_class_1 = json.load(file_class_1)\n    data_class_2 = json.load(file_class_2)\n    data_class_3 = json.load(file_class_3)\n\n    # Assign aggregate values tu agg customer class\n    customer_class_aggregate = CustomerClass()\n    # Agg number of customers\n    customer_class_aggregate.number_of_customers = data_class_1['n_users'] + data_class_2['n_users'] + data_class_3['n_users']\n    # Agg average alphas\n    temp_matrix = (np.asarray(data_class_1['average_alphas']) * data_class_1['n_users']) + (np.asarray(data_class_2['average_alphas']) * data_class_2['n_users']) + (np.asarray(data_class_3['average_alphas']) * data_class_3['n_users'])\n    customer_class_aggregate.alpha_probabilities = temp_matrix / customer_class_aggregate.number_of_customers\n    # Agg reservation prices\n    temp_matrix = (np.asarray(data_class_1['reservation_prices']) * data_class_1['n_users']) + (np.asarray(data_class_2['reservation_prices']) * data_class_2['n_users']) + (np.asarray(data_class_3['reservation_prices']) * data_class_3['n_users'])\n    customer_class_aggregate.reservation_prices = temp_matrix / customer_class_aggregate.number_of_customers\n    # NO AGGREGATE GRAPH BUT ONE GRAPH INITIALIZED TO 1\n    customer_class_aggregate.graph_probabilities = np.ones((5, 5))\n    np.fill_diagonal(customer_class_aggregate.graph_probabilities, 0)\n    # Agg average item sold\n    temp_matrix = (np.asarray(data_class_1['average_items_sold']) * data_class_1['n_users']) + (np.asarray(data_class_2['average_items_sold']) * data_class_2['n_users']) + (np.asarray(data_class_3['average_items_sold']) * data_class_3['n_users'])\n    customer_class_aggregate.item_sold_mean = temp_matrix // customer_class_aggregate.number_of_customers\n\n    return customer_class_aggregate\n\n\ndef get_customer_class_one_feature(user_classes):\n    # Assign aggregate values tu agg customer class\n    customer_class_feature_zero = CustomerClass()\n    customer_class_feature_one = CustomerClass()\n\n    # Agg number of customers\n    # class 0\n    customer_class_feature_zero.number_of_customers = user_classes[0].number_of_customers + user_classes[2].number_of_customers\n    # class 1\n    customer_class_feature_one.number_of_customers = user_classes[1].number_of_customers + user_classes[2].number_of_customers\n    # Agg average alphas\n    # class 0\n    temp_matrix = user_classes[0].number_of_customers * np.asarray(user_classes[0].alpha_probabilities) + user_classes[2].number_of_customers * np.asarray(user_classes[2].alpha_probabilities)\n    customer_class_feature_zero.alpha_probabilities = np.asarray(temp_matrix) / customer_class_feature_zero.number_of_customers\n    # class 1\n    temp_matrix = user_classes[1].number_of_customers * np.asarray(user_classes[1].alpha_probabilities) + user_classes[\n        2].number_of_customers * np.asarray(user_classes[2].alpha_probabilities)\n    customer_class_feature_one.alpha_probabilities = np.asarray(temp_matrix) / customer_class_feature_one.number_of_customers\n\n    # Agg reservation prices\n    # class 0\n    temp_matrix = user_classes[0].number_of_customers * np.asarray(user_classes[0].reservation_prices) + user_classes[2].number_of_customers * np.asarray(user_classes[2].reservation_prices)\n    customer_class_feature_zero.reservation_prices = np.asarray(temp_matrix) / customer_class_feature_zero.number_of_customers\n    # class 1\n    temp_matrix = user_classes[1].number_of_customers * np.asarray(user_classes[1].reservation_prices) + user_classes[\n        2].number_of_customers * np.asarray(user_classes[2].reservation_prices)\n    customer_class_feature_one.reservation_prices = np.asarray(temp_matrix) / customer_class_feature_one.number_of_customers\n\n    # Agg graph probabilities\n    # class 0\n    temp_matrix = user_classes[0].number_of_customers * np.asarray(user_classes[0].graph_probabilities) + user_classes[2].number_of_customers * \\\n                  np.asarray(user_classes[2].graph_probabilities)\n    customer_class_feature_zero.graph_probabilities = np.asarray(temp_matrix) / customer_class_feature_zero.number_of_customers\n    # class 1\n    temp_matrix = user_classes[1].number_of_customers * np.asarray(user_classes[1].graph_probabilities) + user_classes[\n        2].number_of_customers * np.asarray(user_classes[2].graph_probabilities)\n    customer_class_feature_one.graph_probabilities = np.asarray(temp_matrix) / customer_class_feature_one.number_of_customers\n\n    # Agg average item sold\n    # class 0\n    temp_matrix = user_classes[0].number_of_customers * np.asarray(user_classes[0].item_sold_mean) + user_classes[2].number_of_customers * np.asarray(user_classes[2].item_sold_mean)\n    customer_class_feature_zero.item_sold_mean = np.asarray(temp_matrix) / customer_class_feature_zero.number_of_customers\n    # class 1\n    temp_matrix = user_classes[1].number_of_customers * np.asarray(user_classes[1].item_sold_mean) + user_classes[\n        2].number_of_customers * np.asarray(user_classes[2].item_sold_mean)\n    customer_class_feature_one.item_sold_mean = np.asarray(temp_matrix) / customer_class_feature_one.number_of_customers\n\n    return customer_class_feature_zero, customer_class_feature_one\n\n\ndef get_prices_from_json(filename):\n    file = open(filename)\n    data = json.load(file)\n    prices = data[\"prices\"]\n    return prices\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Progetto_Nuovo/Data/DataManager.py b/Progetto_Nuovo/Data/DataManager.py
--- a/Progetto_Nuovo/Data/DataManager.py	(revision 738320252a715d0eaf18efc2c13aa63ffb0668ea)
+++ b/Progetto_Nuovo/Data/DataManager.py	(date 1667558336318)
@@ -1,7 +1,4 @@
 import json
-
-import numpy as np
-
 from Progetto_Nuovo.Data_Structures.CustomerClass import *
 
 
Index: Progetto_Nuovo/Steps/step3.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from termcolor import colored\nfrom Progetto_Nuovo.Environment.Environment import *\nfrom Progetto_Nuovo.Learners.TSLearner import *\nfrom Progetto_Nuovo.Learners.UCBLearner import *\nfrom Progetto_Nuovo.generateData import *\nfrom Progetto_Nuovo.Data.DataManager import *\nfrom Progetto_Nuovo.Data.StatsManager import *\nfrom tqdm import tqdm\n\nn_prices = 4\nn_products = 5\nlambda_coefficient = 0.2\nnumber_of_days = 200\nnumber_of_experiments = 5\ngraph_filename = \"../Data/graph.json\"\nprices_filename = \"../Data/prices.json\"\nuser_class_1 = \"../Data/user_class_1.json\"\nuser_class_2 = \"../Data/user_class_2.json\"\nuser_class_3 = \"../Data/user_class_3.json\"\nmax_units_sold = 1\n\nif __name__ == '__main__':\n    print(colored('\\n\\n---------------------------- STEP 3 ----------------------------', 'blue', attrs=['bold']))\n\n    # assign graph from json file\n    graph = get_graph_from_json(graph_filename)\n    # assign prices per products from json file\n    prices = get_prices_from_json(prices_filename)\n    # generate all the possible price configurations\n    configurations = initialization_other_steps(prices)\n    # generate the customer class from json (aggregate)\n    customer_class = get_customer_class_from_json_aggregate(user_class_1, user_class_2, user_class_3)\n\n    # init reward collection for each experiment TS\n    rewards_per_experiment_ts = []\n    # init reward collection for each experiment UCB\n    rewards_per_experiment_ucb = []\n\n    clairvoyant = evaluate_clairvoyant(configurations, max_units_sold, customer_class.reservation_prices[0],\n                                       customer_class.number_of_customers)\n\n    for e in range(number_of_experiments):\n        print(\"Experiment {0}...\".format(e))\n        # init environment\n        env = Environment(n_prices, customer_class, lambda_coefficient, n_products)\n        # init Thompson Sampling learner\n        ts_learner = TSLearner(n_prices, n_products)\n        # init UCB-1\n        ucb_learner = UCBLearner(n_prices, n_products)\n        total_seen_ucb = np.zeros((n_products, n_prices))\n        total_seen_product_ucb = np.zeros(n_products)\n        # for each day\n        for t in tqdm(range (0, number_of_days)):\n            alpha_ratios = np.random.dirichlet(customer_class.alpha_probabilities)\n            item_sold_mean = customer_class.item_sold_mean\n\n            # THOMPSON SAMPLING\n            # pull prices belonging to a configuration (super arm)\n            pulled_config_indexes_ts = ts_learner.pull_arm()\n            # collect reward trough e-commerce simulation for all the users\n            reward_ts, units_sold_ts, total_seen_ts = env.round(pulled_config_indexes_ts, prices, alpha_ratios,\n                                                                item_sold_mean)\n            # update TS learner parameters\n            ts_learner.update(pulled_config_indexes_ts, units_sold_ts, np.sum(total_seen_ts[1:]), reward_ts)\n\n            # UCB-1\n            pulled_config_indexes_ucb = ucb_learner.pull_arm()\n            pulled_config_indexes_ucb = np.array(np.transpose(pulled_config_indexes_ucb))[0]\n            reward_ucb, units_sold_ucb, total_seen_daily_ucb = env.round(pulled_config_indexes_ucb, prices, alpha_ratios\n                                                                         , item_sold_mean)\n            # seen since day before\n            total_seen_since_daybefore_ucb = np.copy(total_seen_ucb)\n            # seen til now\n            for product in range(len(pulled_config_indexes_ucb)):\n                total_seen_ucb[product, pulled_config_indexes_ucb[product]] += np.sum(total_seen_daily_ucb[1:])\n                total_seen_product_ucb[product] += np.sum(total_seen_daily_ucb[1:])\n            ucb_learner.update(pulled_config_indexes_ucb, units_sold_ucb, total_seen_since_daybefore_ucb, total_seen_ucb,\n                               total_seen_product_ucb, reward_ucb)\n\n        # append collected reward of current experiment TS\n        rewards_per_experiment_ts.append(ts_learner.collected_rewards)\n        # append collected reward of current experiment UCB\n        rewards_per_experiment_ucb.append(ucb_learner.collected_rewards)\n        # printTSBeta(learner.beta_parameters[:, 0, :], rewards_per_experiment[0])\n        # print(\"SOS\", learner.collected_rewards[0])\n    printReward(rewards_per_experiment_ts, clairvoyant)\n    printReward(rewards_per_experiment_ucb, clairvoyant)\n\n    evaluate_mean_std_rewards(rewards_per_experiment_ts)\n    printRegret(rewards_per_experiment_ts, clairvoyant)\n    printRegret(rewards_per_experiment_ucb, clairvoyant)\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Progetto_Nuovo/Steps/step3.py b/Progetto_Nuovo/Steps/step3.py
--- a/Progetto_Nuovo/Steps/step3.py	(revision 738320252a715d0eaf18efc2c13aa63ffb0668ea)
+++ b/Progetto_Nuovo/Steps/step3.py	(date 1667559568533)
@@ -12,18 +12,15 @@
 lambda_coefficient = 0.2
 number_of_days = 200
 number_of_experiments = 5
-graph_filename = "../Data/graph.json"
 prices_filename = "../Data/prices.json"
 user_class_1 = "../Data/user_class_1.json"
 user_class_2 = "../Data/user_class_2.json"
 user_class_3 = "../Data/user_class_3.json"
-max_units_sold = 1
+max_units_sold = 1.5
 
 if __name__ == '__main__':
     print(colored('\n\n---------------------------- STEP 3 ----------------------------', 'blue', attrs=['bold']))
 
-    # assign graph from json file
-    graph = get_graph_from_json(graph_filename)
     # assign prices per products from json file
     prices = get_prices_from_json(prices_filename)
     # generate all the possible price configurations
Index: Progetto_Nuovo/Steps/step7.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from termcolor import colored\nfrom Progetto_Nuovo.Environment.ContextualEnvironment import ContextualEnvironment\nfrom Progetto_Nuovo.Learners.TSLearner import *\nfrom Progetto_Nuovo.Learners.UCBLearner import *\nfrom Progetto_Nuovo.generateData import *\nfrom Progetto_Nuovo.Data.DataManager import *\nfrom Progetto_Nuovo.Data.StatsManager import *\nfrom Progetto_Nuovo.Data_Structures.ContextClass import *\nfrom tqdm import tqdm\n\nn_prices = 4\nn_products = 5\nlambda_coefficient = 0.2\nnumber_of_days = 200\nnumber_of_experiments = 5\ngraph_filename = \"../Data/graph.json\"\nprices_filename = \"../Data/prices.json\"\nuser_class_1 = \"../Data/user_class_1.json\"\nuser_class_2 = \"../Data/user_class_2.json\"\nuser_class_3 = \"../Data/user_class_3.json\"\nmax_units_sold = 1\n\n\ndef estimate_alpha_ratios(old_starts, starts):\n    new_starts = old_starts + starts\n    return new_starts / np.sum(new_starts)\n\n\ndef estimate_items_for_each_product(mean, seen_since_day_before, unit_sold, total_sold):\n    if mean * seen_since_day_before + unit_sold == 0:\n        return 0.\n    return (mean * seen_since_day_before + unit_sold) / total_sold\n\n\nif __name__ == '__main__':\n    print(colored('\\n\\n---------------------------- STEP 7 ----------------------------', 'blue', attrs=['bold']))\n    # INIT PARAMETERS\n    graph = get_graph_from_json(graph_filename)\n    prices = get_prices_from_json(prices_filename)\n    configurations = initialization_other_steps(prices)\n    customer_classes = [get_customer_class_from_json(user_class_1), get_customer_class_from_json(user_class_2),\n                        get_customer_class_from_json(user_class_3),\n                        get_customer_class_from_json_aggregate(user_class_1, user_class_2, user_class_3)]\n    customer_class_zero, customer_class_one = get_customer_class_one_feature(customer_classes)\n    customer_classes.append(customer_class_zero)\n    customer_classes.append(customer_class_one)\n\n    rewards_per_experiment_ts = []\n    rewards_per_experiment_ucb = []\n\n    # EVALUATE CLAIRVOYANT\n    clairvoyant = evaluate_contextual_clairvoyant(configurations, customer_classes, prices)\n\n    for e in range(number_of_experiments):\n        # init environment\n\n        total_seen_ucb = np.zeros((n_products, n_prices))\n        total_seen_product_ucb = np.zeros(n_products)\n        total_seen_ts = np.zeros((n_products, n_prices))\n        total_sold_product_ts = np.zeros((n_products, n_prices))\n        total_sold_product_ucb = np.zeros((n_products, n_prices))\n\n        # initialize alpha ratios for TS\n        alpha_ratios_ts = [0.0, 0.2, 0.2, 0.2, 0.2, 0.2]\n        # initialize alpha ratios for UCB\n        alpha_ratios_ucb = [0.0, 0.2, 0.2, 0.2, 0.2, 0.2]\n        # starts of day before TS\n        old_starts_ts = np.zeros(6)\n        # starts of day before UCB\n        old_starts_ucb = np.zeros(6)\n        # number of unit bought for each price\n        unit_bought = np.ones((n_products, n_prices))\n        # mean of product TS\n        mean_product_ts = np.zeros((n_products, n_prices))\n        # mean of product UCB\n        mean_product_ucb = np.zeros((n_products, n_prices))\n        # initialize item sold mean TS\n        item_sold_mean_ts = [[3 / 2 for _ in range(n_prices)] for _ in range(n_products)]\n        # initialize item sold mean UCB\n        item_sold_mean_ucb = [[3 / 2 for _ in range(n_prices)] for _ in range(n_products)]\n        # for each day\n\n        ucb_learners = []\n        ts_learners = []\n        env = ContextualEnvironment(n_prices, lambda_coefficient, n_products)\n\n        ts_collected_rewards = []\n        ucb_collected_rewards = []\n\n        ucb_split_rewards = [[], []]\n        ts_split_rewards = [[], []]\n\n        context_ts = ContextClass()\n        context_ucb = ContextClass()\n\n        ucb_father_reward = []\n        ts_father_reward = []\n\n        optimum_found = [False, False]\n        optimum_split = [None, None]\n        optimum_learner = [None, None]\n        for t in tqdm(range(0, number_of_days)):\n            # every 14 days run context and do a split\n            if t % 14 == 0:\n                # UCB LEARNER\n                if not optimum_found[0]:\n                    #ucb_learners = []\n                    if t == 0:\n                        context_ucb.split()\n                    elif t == 14:\n                        ucb_father_reward.append(ucb_split_rewards[0])\n                        ucb_collected_rewards.append(ucb_split_rewards[0])\n                        context_ucb.assign_father_lower_bound(ucb_split_rewards[0])\n                        context_ucb.split()\n                    else:\n                        split = context_ucb.current_split\n                        check, l_reward, r_reward = context_ucb.evaluate_split_condition(ucb_split_rewards[0],\n                                                                                         ucb_split_rewards[1], t)\n                        context_ucb.split(check, l_reward, r_reward)\n                        # if the split is worth...\n                        if check:\n                            # if the left node is better than the right node it becomes the father node\n                            if l_reward > r_reward:\n                                if len(ucb_learners) > 0:\n                                    optimum_split[0] = split[0]\n                                    optimum_learner[0] = ucb_learners[0]\n                                # 0 -> left, 1 -> right\n                                ucb_father_reward.append(ucb_split_rewards[0])\n                                ucb_collected_rewards.append(ucb_split_rewards[0])\n                                context_ucb.father_lower_bound = l_reward\n                                context_ucb.pending_list_lower_bounds.append(\n                                    context_ucb.lower_bound(ucb_split_rewards[1], 5, 14))\n                                context_ucb.pending_list_prob.append(context_ucb.assign_prob_context_occur(t))\n                            else:\n                                if len(ucb_learners) > 0:\n                                    optimum_split[0] = split[1]\n                                    optimum_learner[0] = ucb_learners[1]\n                                ucb_father_reward.append(ucb_split_rewards[1])\n                                ucb_collected_rewards.append(ucb_split_rewards[1])\n                                context_ucb.father_lower_bound = r_reward\n                                context_ucb.pending_list_lower_bounds.append(\n                                    context_ucb.lower_bound(ucb_split_rewards[0], 5, 14))\n                                context_ucb.pending_list_prob.append(context_ucb.assign_prob_context_occur(t))\n                        # if the split isn't worth...\n                        else:\n                            if len(context_ucb.pending_list) > 0:\n                                ucb_collected_rewards.append(ucb_father_reward.pop(0))\n                                context_ucb.father_lower_bound = context_ucb.pending_list_lower_bounds[0]\n                                context_ucb.pending_list_lower_bounds.pop(0)\n                                context_ucb.pending_list_prob.pop(0)\n                            else:\n                                context_ucb.current_split = optimum_split[0]\n                                optimum_found[0] = True\n                else:\n                    ucb_collected_rewards.append(ucb_split_rewards[0])\n\n                # TS LEARNER\n                if not optimum_found[1]:\n                    #ts_learners = []\n                    if t == 0:\n                        context_ts.split()\n                    elif t == 14:\n                        ts_father_reward.append(ts_split_rewards[0])\n                        ts_collected_rewards.append(ts_split_rewards[0])\n                        context_ts.assign_father_lower_bound(ts_split_rewards[0])\n                        context_ts.split()\n                    else:\n                        split = context_ts.current_split\n                        check, l_reward, r_reward = context_ts.evaluate_split_condition(ts_split_rewards[0],\n                                                                                        ts_split_rewards[1], t)\n                        context_ts.split(check, l_reward, r_reward)\n                        if check:\n                            if l_reward > r_reward:\n                                # 0 -> left, 1 -> right\n                                if len(ts_learners) > 1:\n                                    optimum_split[1] = split[0]\n                                    optimum_learner[1] = ts_learners[0]\n                                ts_father_reward.append(ts_split_rewards[0])\n                                ts_collected_rewards.append(ts_split_rewards[0])\n                                context_ts.father_lower_bound = l_reward\n                                context_ts.pending_list_lower_bounds.append(\n                                    context_ts.lower_bound(ts_split_rewards[1], 5, 14))\n                                context_ts.pending_list_prob.append(context_ts.assign_prob_context_occur(t))\n                            else:\n                                if len(ts_learners) > 1:\n                                    optimum_split[1] = split[1]\n                                    optimum_learner[1] = ts_learners[1]\n                                ts_father_reward.append(ts_split_rewards[1])\n                                ts_collected_rewards.append(ts_split_rewards[1])\n                                context_ts.father_lower_bound = r_reward\n                                context_ts.pending_list_lower_bounds.append(\n                                    context_ts.lower_bound(ts_split_rewards[0], 5, 14))\n                                context_ts.pending_list_prob.append(context_ts.assign_prob_context_occur(t))\n\n                        else:\n                            if len(context_ts.pending_list) > 0:\n                                ts_collected_rewards.append(list(ts_father_reward.pop(0)))\n                                context_ts.father_lower_bound = context_ts.pending_list_lower_bounds[0]\n                                context_ts.pending_list_lower_bounds.pop(0)\n                                context_ts.pending_list_prob.pop(0)\n                            else:\n                                context_ts.current_split = optimum_split[1]\n                                optimum_found[1] = True\n                else:\n                    ts_collected_rewards.append(ts_split_rewards[0])\n\n                if not optimum_found[0]:\n                    ucb_split_rewards = [[], []]\n                if not optimum_found[1]:\n                    ts_split_rewards = [[], []]\n\n            # ---------------------------------------THOMPSON SAMPLING----------------------------------\n            i = 0\n            if not optimum_found[1]:\n                ts_learners = []\n            if not optimum_found[0]:\n                ucb_learners = []\n            for split in context_ts.current_split:\n                if not optimum_found[1]:\n                    ts_learners.append(TSLearner(n_prices, n_products))\n                pulled_config_indexes_ts = ts_learners[i].pull_arm()\n                env.select_costumer_class(customer_classes[get_json_from_binary_feature(split)])\n                reward_ts, units_sold_ts, total_seen_daily_ts = env.round(pulled_config_indexes_ts, prices,\n                                                                          alpha_ratios_ts, item_sold_mean_ts)\n                ts_split_rewards[i].append(reward_ts)\n                ts_learners[i].update(pulled_config_indexes_ts, units_sold_ts, np.sum(total_seen_daily_ts[1:]), reward_ts)\n                alpha_ratios_ts = estimate_alpha_ratios(old_starts_ts, total_seen_daily_ts)\n                total_bought_since_day_before_ts = np.copy(total_sold_product_ts)\n                for p in range(len(pulled_config_indexes_ts)):\n                    total_seen_ts[p, pulled_config_indexes_ts[p]] += np.sum(total_seen_daily_ts[1:])\n                    total_sold_product_ts[p, pulled_config_indexes_ts[p]] += units_sold_ts[p]\n                    item_sold_mean_ts[p][pulled_config_indexes_ts[p]] = estimate_items_for_each_product(\n                        item_sold_mean_ts[p][pulled_config_indexes_ts[p]],\n                        total_bought_since_day_before_ts[p, pulled_config_indexes_ts[p]], units_sold_ts[p],\n                        total_sold_product_ts[p, pulled_config_indexes_ts[p]])\n                i += 1\n\n            # ---------------------------------------------UCB-------------------------------------------\n            i = 0\n            for split in context_ucb.current_split:\n                if not optimum_found[0]:\n                    ucb_learners.append(UCBLearner(n_prices, n_products))\n                pulled_config_indexes_ucb = ucb_learners[i].pull_arm()\n                pulled_config_indexes_ucb = np.array(np.transpose(pulled_config_indexes_ucb))[0]\n                env.select_costumer_class(customer_classes[get_json_from_binary_feature(split)])\n                reward_ucb, units_sold_ucb, total_seen_daily_ucb = env.round(pulled_config_indexes_ucb, prices,\n                                                                             alpha_ratios_ucb, item_sold_mean_ucb)\n                ucb_split_rewards[i].append(reward_ucb)\n                total_seen_since_day_before_ucb = np.copy(total_seen_ucb)\n                for p in range(len(pulled_config_indexes_ucb)):\n                    total_seen_ucb[p, pulled_config_indexes_ucb[p]] += np.sum(total_seen_daily_ucb[1:])\n                    total_seen_product_ucb[p] += np.sum(total_seen_daily_ucb[1:])\n                ucb_learners[i].update(pulled_config_indexes_ucb, units_sold_ucb, total_seen_since_day_before_ucb,\n                                   total_seen_ucb, total_seen_product_ucb, reward_ucb)\n                alpha_ratios_ucb = estimate_alpha_ratios(old_starts_ucb, total_seen_daily_ucb)\n                total_bought_since_day_before_ucb = np.copy(total_sold_product_ucb)\n                for p in range(len(pulled_config_indexes_ucb)):\n                    total_sold_product_ucb[p, pulled_config_indexes_ucb[p]] += units_sold_ucb[p]\n                    item_sold_mean_ucb[p][pulled_config_indexes_ucb[p]] = estimate_items_for_each_product(\n                        item_sold_mean_ucb[p][pulled_config_indexes_ucb[p]],\n                        total_bought_since_day_before_ucb[p][pulled_config_indexes_ucb[p]],\n                        units_sold_ucb[p], total_sold_product_ucb[p][pulled_config_indexes_ucb[p]])\n                i += 1\n        rewards_per_experiment_ucb.append(ucb_collected_rewards)\n        rewards_per_experiment_ts.append(ts_collected_rewards)\n    print_contextual_graphs(rewards_per_experiment_ucb, clairvoyant)\n    print_contextual_graphs(rewards_per_experiment_ts, clairvoyant)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Progetto_Nuovo/Steps/step7.py b/Progetto_Nuovo/Steps/step7.py
--- a/Progetto_Nuovo/Steps/step7.py	(revision 738320252a715d0eaf18efc2c13aa63ffb0668ea)
+++ b/Progetto_Nuovo/Steps/step7.py	(date 1667558987464)
@@ -13,7 +13,6 @@
 lambda_coefficient = 0.2
 number_of_days = 200
 number_of_experiments = 5
-graph_filename = "../Data/graph.json"
 prices_filename = "../Data/prices.json"
 user_class_1 = "../Data/user_class_1.json"
 user_class_2 = "../Data/user_class_2.json"
@@ -35,7 +34,6 @@
 if __name__ == '__main__':
     print(colored('\n\n---------------------------- STEP 7 ----------------------------', 'blue', attrs=['bold']))
     # INIT PARAMETERS
-    graph = get_graph_from_json(graph_filename)
     prices = get_prices_from_json(prices_filename)
     configurations = initialization_other_steps(prices)
     customer_classes = [get_customer_class_from_json(user_class_1), get_customer_class_from_json(user_class_2),
@@ -53,7 +51,6 @@
 
     for e in range(number_of_experiments):
         # init environment
-
         total_seen_ucb = np.zeros((n_products, n_prices))
         total_seen_product_ucb = np.zeros(n_products)
         total_seen_ts = np.zeros((n_products, n_prices))
@@ -104,7 +101,6 @@
             if t % 14 == 0:
                 # UCB LEARNER
                 if not optimum_found[0]:
-                    #ucb_learners = []
                     if t == 0:
                         context_ucb.split()
                     elif t == 14:
@@ -156,7 +152,6 @@
 
                 # TS LEARNER
                 if not optimum_found[1]:
-                    #ts_learners = []
                     if t == 0:
                         context_ts.split()
                     elif t == 14:
@@ -251,7 +246,7 @@
                     total_seen_ucb[p, pulled_config_indexes_ucb[p]] += np.sum(total_seen_daily_ucb[1:])
                     total_seen_product_ucb[p] += np.sum(total_seen_daily_ucb[1:])
                 ucb_learners[i].update(pulled_config_indexes_ucb, units_sold_ucb, total_seen_since_day_before_ucb,
-                                   total_seen_ucb, total_seen_product_ucb, reward_ucb)
+                                       total_seen_ucb, total_seen_product_ucb, reward_ucb)
                 alpha_ratios_ucb = estimate_alpha_ratios(old_starts_ucb, total_seen_daily_ucb)
                 total_bought_since_day_before_ucb = np.copy(total_sold_product_ucb)
                 for p in range(len(pulled_config_indexes_ucb)):
Index: Progetto_Nuovo/Steps/step5.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from termcolor import colored\nfrom Progetto_Nuovo.Environment.Environment import *\nfrom Progetto_Nuovo.Learners.TSLearner import *\nfrom Progetto_Nuovo.Learners.UCBLearner import *\nfrom Progetto_Nuovo.generateData import *\nfrom Progetto_Nuovo.Data.DataManager import *\nfrom Progetto_Nuovo.Data.StatsManager import *\nfrom tqdm import tqdm\n\nn_prices = 4\nn_products = 5\nlambda_coefficient = 0.2\nnumber_of_days = 25\nnumber_of_experiments = 5\ngraph_filename = \"../Data/graph.json\"\nprices_filename = \"../Data/prices.json\"\nuser_class_1_filename = \"../Data/user_class_1.json\"\nuser_class_2_filename = \"../Data/user_class_2.json\"\nuser_class_3_filename = \"../Data/user_class_3.json\"\nmax_units_sold = 2\n\nif __name__ == '__main__':\n    print(colored('\\n\\n---------------------------- STEP 3 ----------------------------', 'blue', attrs=['bold']))\n\n    # assign graph from json file\n    graph = get_graph_from_json(graph_filename)\n    # assign prices per products from json file\n    prices = get_prices_from_json(prices_filename)\n    # generate all the possible price configurations\n    configurations = initialization_other_steps(prices)\n    # generate the customer class from json (aggregate)\n    customer_class = get_customer_class_from_json_aggregate_unknown_graph(user_class_1_filename, user_class_2_filename,\n                                                                          user_class_3_filename)\n    # init reward collection for each experiment TS\n    rewards_per_experiment_ts = []\n    # init reward collection for each experiment UCB\n    rewards_per_experiment_ucb = []\n\n    clairvoyant = evaluate_clairvoyant(configurations, max_units_sold, customer_class.reservation_prices[0],\n                                       customer_class.number_of_customers)\n\n    for e in range(number_of_experiments):\n        print(\"Experiment {0}...\".format(e))\n        # init environment\n        env = Environment(n_prices, customer_class, lambda_coefficient, n_products)\n        # init Thompson Sampling learner\n        ts_learner = TSLearner(n_prices, n_products)\n        # init UCB-1\n        ucb_learner = UCBLearner(n_prices, n_products)\n        total_seen_ucb = np.zeros((n_products, n_prices))\n        total_seen_product_ucb = np.zeros(n_products)\n        # init both\n        total_bought = np.zeros(5)\n        # for each day\n        for t in tqdm(range (0, number_of_days)):\n            alpha_ratios = np.random.dirichlet(customer_class.alpha_probabilities)\n            item_sold_mean = customer_class.item_sold_mean\n\n            # THOMPSON SAMPLING\n            # pull prices belonging to a configuration (super arm)\n            pulled_config_indexes_ts = ts_learner.pull_arm()\n            # collect reward trough e-commerce simulation for all the users\n            reward_ts, units_sold_ts, total_seen_ts = env.round(pulled_config_indexes_ts, prices, alpha_ratios,\n                                                                item_sold_mean)\n            # update TS learner parameters\n            ts_learner.update(pulled_config_indexes_ts, units_sold_ts, np.sum(total_seen_ts[1:]), reward_ts)\n\n            # UCB-1\n            pulled_config_indexes_ucb = ucb_learner.pull_arm()\n            pulled_config_indexes_ucb = np.array(np.transpose(pulled_config_indexes_ucb))[0]\n            reward_ucb, units_sold_ucb, total_seen_daily_ucb = env.round(pulled_config_indexes_ucb, prices, alpha_ratios\n                                                                         , item_sold_mean)\n            # seen since day before\n            total_seen_since_daybefore_ucb = np.copy(total_seen_ucb)\n            # seen til now\n            for product in range(len(pulled_config_indexes_ucb)):\n                total_seen_ucb[product, pulled_config_indexes_ucb[product]] += np.sum(total_seen_daily_ucb[1:])\n                total_seen_product_ucb[product] += np.sum(total_seen_daily_ucb[1:])\n            ucb_learner.update(pulled_config_indexes_ucb, units_sold_ucb, total_seen_since_daybefore_ucb, total_seen_ucb,\n                               total_seen_product_ucb, reward_ucb)\n\n            # bought since day before\n            total_bought_day_before = np.copy(total_bought)\n            # bought til now\n            total_bought += (units_sold_ucb + units_sold_ts)\n            for product in range(len(customer_class.units_clicked_starting_from_a_primary)):\n                customer_class.graph_probabilities[product, :] = (customer_class.graph_probabilities[product, :] * total_bought_day_before[product] + customer_class.units_clicked_starting_from_a_primary[product, :]) / total_bought[product]\n\n\n        # append collected reward of current experiment TS\n        rewards_per_experiment_ts.append(ts_learner.collected_rewards)\n        # append collected reward of current experiment UCB\n        rewards_per_experiment_ucb.append(ucb_learner.collected_rewards)\n        # printTSBeta(learner.beta_parameters[:, 0, :], rewards_per_experiment[0])\n        # print(\"SOS\", learner.collected_rewards[0])\n    printReward(rewards_per_experiment_ts, clairvoyant)\n    printReward(rewards_per_experiment_ucb, clairvoyant)\n\n    evaluate_mean_std_rewards(rewards_per_experiment_ts)\n    printRegret(rewards_per_experiment_ts, clairvoyant)\n    printRegret(rewards_per_experiment_ucb, clairvoyant)\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Progetto_Nuovo/Steps/step5.py b/Progetto_Nuovo/Steps/step5.py
--- a/Progetto_Nuovo/Steps/step5.py	(revision 738320252a715d0eaf18efc2c13aa63ffb0668ea)
+++ b/Progetto_Nuovo/Steps/step5.py	(date 1667558987485)
@@ -10,20 +10,17 @@
 n_prices = 4
 n_products = 5
 lambda_coefficient = 0.2
-number_of_days = 25
+number_of_days = 200
 number_of_experiments = 5
-graph_filename = "../Data/graph.json"
 prices_filename = "../Data/prices.json"
 user_class_1_filename = "../Data/user_class_1.json"
 user_class_2_filename = "../Data/user_class_2.json"
 user_class_3_filename = "../Data/user_class_3.json"
-max_units_sold = 2
+max_units_sold = 1
 
 if __name__ == '__main__':
     print(colored('\n\n---------------------------- STEP 3 ----------------------------', 'blue', attrs=['bold']))
 
-    # assign graph from json file
-    graph = get_graph_from_json(graph_filename)
     # assign prices per products from json file
     prices = get_prices_from_json(prices_filename)
     # generate all the possible price configurations
Index: Progetto_Nuovo/Steps/step6.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from termcolor import colored\nfrom Progetto_Nuovo.Environment.Environment import *\nfrom Progetto_Nuovo.Learners.SWUCBLearner import *\nfrom Progetto_Nuovo.generateData import *\nfrom Progetto_Nuovo.Data.DataManager import *\nfrom Progetto_Nuovo.Data.StatsManager import *\nfrom Progetto_Nuovo.Learners.CDUCBLearner import *\nfrom Progetto_Nuovo.Environment.NonStationaryEnvironment import *\nfrom tqdm import tqdm\n\nn_prices = 4\nn_products = 5\nlambda_coefficient = 0.2\nnumber_of_days = 100\nwindow = 25\nnumber_of_experiments = 5\ngraph_filename = \"../Data/graph.json\"\nprices_filename = \"../Data/prices.json\"\nuser_class_filename = \"../Data/user_class_aggregate_abrupt_changes.json\"\nmax_units_sold = 1.5\nn_phases = 4\n\nif __name__ == '__main__':\n    print(colored('\\n\\n---------------------------- STEP 6 ----------------------------', 'blue', attrs=['bold']))\n    cd_ucb_phase = 0\n    sw_ucb_phase = 0\n    # assign graph from json file\n    graph = get_graph_from_json(graph_filename)\n    # assign prices per products from json file\n    prices = get_prices_from_json(prices_filename)\n    # generate all the possible price configurations\n    configurations = initialization_other_steps(prices)\n    # generate the customer class from json (aggregate)\n    customer_class = get_customer_class_from_json(user_class_filename)\n\n    # init reward collection for each experiment CD-UCB\n    rewards_per_experiment_cducb = []\n    # init reward collection for each experiment UCB\n    rewards_per_experiment_ucb = []\n\n    for e in range(number_of_experiments):\n        print(\"Experiment {0}...\".format(e))\n        # init environment\n        env = NonStationaryEnvironment(n_prices, customer_class, lambda_coefficient, n_products)\n        # init CD-UCB learner\n        cd_ucb_learner = CDUCBLearner(n_prices, n_products)\n        # init UCB-1\n        ucb_learner = SWUCBLearner(n_prices, n_products)\n\n        total_seen_cducb = np.zeros((n_products, n_prices))\n        total_seen_product_cducb = np.zeros(n_products)\n\n        total_seen_ucb = np.zeros((n_products, n_prices))\n        total_seen_product_ucb = np.zeros(n_products)\n        total_seen_product_per_window_ucb = np.zeros(n_products)\n        # for each day\n        for t in tqdm(range(0, number_of_days)):\n            alpha_ratios = np.random.dirichlet(customer_class.alpha_probabilities)\n            item_sold_mean = customer_class.item_sold_mean\n\n            # UCB-1\n            pulled_config_indexes_ucb = ucb_learner.pull_arm()\n            pulled_config_indexes_ucb = np.array(np.transpose(pulled_config_indexes_ucb))[0]\n            reward_ucb, units_sold_ucb, total_seen_daily_ucb = env.round(pulled_config_indexes_ucb, prices, alpha_ratios\n                                                                         , item_sold_mean, sw_ucb_phase)\n            # CD-UCB\n            pulled_config_indexes_cducb = cd_ucb_learner.pull_arm()\n            pulled_config_indexes_cducb = np.array(np.transpose(pulled_config_indexes_cducb))[0]\n            reward_cducb, units_sold_cducb, total_seen_daily_cducb = env.round(pulled_config_indexes_ucb, prices, alpha_ratios, item_sold_mean, cd_ucb_phase)\n\n\n            # seen since day before\n            total_seen_since_daybefore_ucb = np.copy(total_seen_ucb)\n            # seen since day before\n            total_seen_since_daybefore_cducb = np.copy(total_seen_cducb)\n            # seen til now\n            for product in range(len(pulled_config_indexes_ucb)):\n                total_seen_ucb[product, pulled_config_indexes_ucb[product]] += np.sum(total_seen_daily_ucb[1:])\n                total_seen_product_ucb[product] += np.sum(total_seen_daily_ucb[1:])\n                total_seen_product_per_window_ucb[product] += np.sum(total_seen_daily_ucb[1:])\n            ucb_learner.update(pulled_config_indexes_ucb, units_sold_ucb, total_seen_since_daybefore_ucb, total_seen_ucb,\n                               total_seen_product_ucb, total_seen_product_per_window_ucb, reward_ucb)\n\n            for product in range(len(pulled_config_indexes_cducb)):\n                total_seen_cducb[product, pulled_config_indexes_cducb[product]] += np.sum(total_seen_daily_cducb[1:])\n                total_seen_product_cducb[product] += np.sum(total_seen_daily_cducb[1:])\n            cd_ucb_learner.update(pulled_config_indexes_cducb, units_sold_cducb, total_seen_since_daybefore_cducb,\n                                  total_seen_cducb, total_seen_product_cducb, reward_cducb)\n            if cd_ucb_learner.detect_change(pulled_config_indexes_cducb):\n                if cd_ucb_phase < 3:\n                    cd_ucb_phase += 1\n                total_seen_cducb = np.zeros((n_products, n_prices))\n                total_seen_product_per_window_cducb = np.zeros(n_products)\n                # initialize for the next window of 25 days\n            if t != 0 and t % window == 0:\n                if sw_ucb_phase < 3:\n                    sw_ucb_phase += 1\n                total_seen_ucb = np.zeros((n_products, n_prices))\n                total_seen_product_per_window_ucb = np.zeros(n_products)\n\n        # append collected reward of current experiment UCB\n        rewards_per_experiment_ucb.append(ucb_learner.collected_rewards)\n        rewards_per_experiment_cducb.append(cd_ucb_learner.collected_rewards)\n        # printTSBeta(learner.beta_parameters[:, 0, :], rewards_per_experiment[0])\n        # print(\"SOS\", learner.collected_rewards[0])\n    #printReward(rewards_per_experiment_cducb, clairvoyant)\n    #printReward(rewards_per_experiment_ucb, clairvoyant)\n\n    #evaluate_mean_std_rewards(rewards_per_experiment_cducb)\n    #printRegret(rewards_per_experiment_cducb, clairvoyant)\n    #printRegret(rewards_per_experiment_ucb, clairvoyant)\n\n    clairvoyant_phases = evaluate_abrupt_changes_clairvoyant(configurations, max_units_sold, customer_class.reservation_prices,\n                                       customer_class.number_of_customers, n_phases)\n\n    cd_ucb_instantaneus_regret = np.zeros(number_of_days)\n    sw_ucb_instantaneus_regret = np.zeros(number_of_days)\n    optimum_per_round = np.zeros(number_of_days)\n\n    for i in range(n_phases):\n        t_index = range(i*window, (i+1)*window)\n        optimum_per_round[t_index] = clairvoyant_phases[i]\n        cd_ucb_instantaneus_regret[t_index] = clairvoyant_phases[i] -np.mean(rewards_per_experiment_cducb, axis=0)[t_index]\n        sw_ucb_instantaneus_regret[t_index] = clairvoyant_phases[i] -np.mean(rewards_per_experiment_ucb, axis=0)[t_index]\n\n    plt.figure(0)\n    plt.plot(np.mean(rewards_per_experiment_cducb, axis=0), 'r')\n    plt.plot(np.mean(rewards_per_experiment_ucb, axis=0), 'b')\n    plt.plot(optimum_per_round, 'k--')\n    plt.legend(['CD-UCB', 'SW-UCB', 'Clairvoyant'])\n    plt.xlabel(\"t\")\n    plt.ylabel(\"Reward\")\n\n    plt.figure(1)\n    plt.plot(np.cumsum(cd_ucb_instantaneus_regret), 'r')\n    plt.plot(np.cumsum(sw_ucb_instantaneus_regret), 'b')\n    plt.legend(['CD-UCB', 'SW-UCB'])\n    plt.xlabel(\"t\")\n    plt.ylabel(\"Regret\")\n    plt.show()\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Progetto_Nuovo/Steps/step6.py b/Progetto_Nuovo/Steps/step6.py
--- a/Progetto_Nuovo/Steps/step6.py	(revision 738320252a715d0eaf18efc2c13aa63ffb0668ea)
+++ b/Progetto_Nuovo/Steps/step6.py	(date 1667558987451)
@@ -11,21 +11,18 @@
 n_prices = 4
 n_products = 5
 lambda_coefficient = 0.2
-number_of_days = 100
+number_of_days = 200
 window = 25
 number_of_experiments = 5
-graph_filename = "../Data/graph.json"
 prices_filename = "../Data/prices.json"
 user_class_filename = "../Data/user_class_aggregate_abrupt_changes.json"
-max_units_sold = 1.5
+max_units_sold = 1
 n_phases = 4
 
 if __name__ == '__main__':
     print(colored('\n\n---------------------------- STEP 6 ----------------------------', 'blue', attrs=['bold']))
     cd_ucb_phase = 0
     sw_ucb_phase = 0
-    # assign graph from json file
-    graph = get_graph_from_json(graph_filename)
     # assign prices per products from json file
     prices = get_prices_from_json(prices_filename)
     # generate all the possible price configurations
Index: Progetto_Nuovo/Steps/step4.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from termcolor import colored\nfrom Progetto_Nuovo.Environment.Environment import *\nfrom Progetto_Nuovo.Learners.TSLearner import *\nfrom Progetto_Nuovo.Learners.UCBLearner import *\nfrom Progetto_Nuovo.generateData import *\nfrom Progetto_Nuovo.Data.DataManager import *\nfrom Progetto_Nuovo.Data.StatsManager import *\nfrom tqdm import tqdm\n\nn_prices = 4\nn_products = 5\nlambda_coefficient = 0.2\nnumber_of_days = 100\nnumber_of_experiments = 2\ngraph_filename = \"../Data/graph.json\"\nprices_filename = \"../Data/prices.json\"\nuser_class_1 = \"../Data/user_class_1.json\"\nuser_class_2 = \"../Data/user_class_2.json\"\nuser_class_3 = \"../Data/user_class_3.json\"\nmax_units_sold = 1\n\n\ndef estimate_alpha_ratios(old_starts, starts):\n    new_starts = old_starts + starts\n    return new_starts / np.sum(new_starts)\n\n\ndef estimate_items_for_each_product(mean, seen_since_day_before, unit_sold, total_sold):\n    if mean * seen_since_day_before + unit_sold == 0:\n        return 0.\n    if total_sold == 0:\n        print(\"ciao\")\n    return (mean * seen_since_day_before + unit_sold) / total_sold\n\n\nif __name__ == '__main__':\n    print(colored('\\n\\n---------------------------- STEP 4 ----------------------------', 'blue', attrs=['bold']))\n\n    # assign graph from json file\n    graph = get_graph_from_json(graph_filename)\n    # assign prices per products from json file\n    prices = get_prices_from_json(prices_filename)\n    # generate all the possible price configurations\n    configurations = initialization_other_steps(prices)\n    # generate the customer class from json (aggregate)\n    customer_class = get_customer_class_from_json_aggregate(user_class_1, user_class_2, user_class_3)\n    # init reward collection for each experiment TS\n    rewards_per_experiment_ts = []\n    # init reward collection for each experiment UCB\n    rewards_per_experiment_ucb = []\n\n    clairvoyant = evaluate_clairvoyant(configurations, max_units_sold, customer_class.reservation_prices[0],\n                                       customer_class.number_of_customers)\n\n    for e in range(number_of_experiments):\n        # init environment\n        env = Environment(n_prices, customer_class, lambda_coefficient, n_products)\n        # init Thompson Sampling learner\n        ts_learner = TSLearner(n_prices, n_products)\n        # init UCB-1\n        ucb_learner = UCBLearner(n_prices, n_products)\n\n        total_seen_ucb = np.zeros((n_products, n_prices))\n        total_seen_product_ucb = np.zeros(n_products)\n        total_seen_ts = np.zeros((n_products, n_prices))\n        total_sold_product_ts = np.zeros((n_products, n_prices))\n        total_sold_product_ucb = np.zeros((n_products, n_prices))\n\n        # initialize alpha ratios for TS\n        alpha_ratios_ts = [0.0, 0.2, 0.2, 0.2, 0.2, 0.2]\n        # initialize alpha ratios for UCB\n        alpha_ratios_ucb = [0.0, 0.2, 0.2, 0.2, 0.2, 0.2]\n        # starts of day before TS\n        old_starts_ts = np.zeros(6)\n        # starts of day before UCB\n        old_starts_ucb = np.zeros(6)\n        # number of unit bought for each price\n        unit_bought = np.ones((n_products, n_prices))\n        # mean of product TS\n        mean_product_ts = np.zeros((n_products, n_prices))\n        # mean of product UCB\n        mean_product_ucb = np.zeros((n_products, n_prices))\n        # initialize item sold mean TS\n        item_sold_mean_ts = [[3/2 for _ in range(n_prices)] for _ in range(n_products)]\n        # initialize item sold mean UCB\n        item_sold_mean_ucb = [[3/2 for _ in range(n_prices)] for _ in range(n_products)]\n        # for each day\n        for t in range(0, number_of_days):\n            # ---------------------------------------THOMPSON SAMPLING----------------------------------\n            # pull prices belonging to a configuration (super arm)\n            pulled_config_indexes_ts = ts_learner.pull_arm()\n            # collect reward trough e-commerce simulation for all the users\n            reward_ts, units_sold_ts, total_seen_daily_ts = env.round(pulled_config_indexes_ts, prices, alpha_ratios_ts,\n                                                                      item_sold_mean_ts)\n            # update TS learner parameters\n            ts_learner.update(pulled_config_indexes_ts, units_sold_ts, np.sum(total_seen_daily_ts[1:]), reward_ts)\n\n            # ------------------------------------------alpha ratio-------------------------------------\n\n            # call alpha estimate for TS\n            alpha_ratios_ts = estimate_alpha_ratios(old_starts_ts, total_seen_daily_ts)\n\n            # ------------------------------------------unit bought-------------------------------------\n\n            # bought since day before\n            total_bought_since_day_before_ts = np.copy(total_sold_product_ts)\n\n            # seen til now\n            for p in range(len(pulled_config_indexes_ts)):\n                total_seen_ts[p, pulled_config_indexes_ts[p]] += np.sum(total_seen_daily_ts[1:])\n                total_sold_product_ts[p, pulled_config_indexes_ts[p]] += units_sold_ts[p]\n                # call unit bought for product estimate\n                item_sold_mean_ts[p][pulled_config_indexes_ts[p]] = estimate_items_for_each_product(\n                    item_sold_mean_ts[p][pulled_config_indexes_ts[p]],\n                    total_bought_since_day_before_ts[p, pulled_config_indexes_ts[p]], units_sold_ts[p],\n                    total_sold_product_ts[p, pulled_config_indexes_ts[p]])\n\n            # ---------------------------------------------UCB-------------------------------------------\n\n            # UCB-1\n            pulled_config_indexes_ucb = ucb_learner.pull_arm()\n            pulled_config_indexes_ucb = np.array(np.transpose(pulled_config_indexes_ucb))[0]\n            reward_ucb, units_sold_ucb, total_seen_daily_ucb = env.round(pulled_config_indexes_ucb, prices,\n                                                                         alpha_ratios_ucb, item_sold_mean_ucb)\n            # seen since day before\n            total_seen_since_day_before_ucb = np.copy(total_seen_ucb)\n            # seen til now\n            for p in range(len(pulled_config_indexes_ucb)):\n                total_seen_ucb[p, pulled_config_indexes_ucb[p]] += np.sum(total_seen_daily_ucb[1:])\n                total_seen_product_ucb[p] += np.sum(total_seen_daily_ucb[1:])\n            ucb_learner.update(pulled_config_indexes_ucb, units_sold_ucb, total_seen_since_day_before_ucb,\n                               total_seen_ucb, total_seen_product_ucb, reward_ucb)\n\n            # ------------------------------------------alpha ratio-------------------------------------\n\n            # call alpha estimate for UCB\n            alpha_ratios_ucb = estimate_alpha_ratios(old_starts_ucb, total_seen_daily_ucb)\n\n            # ------------------------------------------unit bought-------------------------------------\n\n            # seen since day before\n            total_bought_since_day_before_ucb = np.copy(total_sold_product_ucb)\n\n            # seen til now\n            for p in range(len(pulled_config_indexes_ucb)):\n                total_sold_product_ucb[p, pulled_config_indexes_ucb[p]] += units_sold_ucb[p]\n                # call unit bought for product estimate\n                item_sold_mean_ucb[p][pulled_config_indexes_ucb[p]] = estimate_items_for_each_product(\n                    item_sold_mean_ucb[p][pulled_config_indexes_ucb[p]],\n                    total_bought_since_day_before_ucb[p][pulled_config_indexes_ucb[p]],\n                    units_sold_ucb[p], total_sold_product_ucb[p][pulled_config_indexes_ucb[p]])\n\n        # append collected reward of current experiment TS\n        rewards_per_experiment_ts.append(ts_learner.collected_rewards)\n        # append collected reward of current experiment UCB\n        rewards_per_experiment_ucb.append(ucb_learner.collected_rewards)\n\n        printReward(rewards_per_experiment_ts, clairvoyant)\n        printReward(rewards_per_experiment_ucb, clairvoyant)\n\n        printRegret(rewards_per_experiment_ts, clairvoyant)\n        printRegret(rewards_per_experiment_ucb, clairvoyant)\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Progetto_Nuovo/Steps/step4.py b/Progetto_Nuovo/Steps/step4.py
--- a/Progetto_Nuovo/Steps/step4.py	(revision 738320252a715d0eaf18efc2c13aa63ffb0668ea)
+++ b/Progetto_Nuovo/Steps/step4.py	(date 1667558614631)
@@ -10,9 +10,8 @@
 n_prices = 4
 n_products = 5
 lambda_coefficient = 0.2
-number_of_days = 100
-number_of_experiments = 2
-graph_filename = "../Data/graph.json"
+number_of_days = 200
+number_of_experiments = 5
 prices_filename = "../Data/prices.json"
 user_class_1 = "../Data/user_class_1.json"
 user_class_2 = "../Data/user_class_2.json"
@@ -36,8 +35,6 @@
 if __name__ == '__main__':
     print(colored('\n\n---------------------------- STEP 4 ----------------------------', 'blue', attrs=['bold']))
 
-    # assign graph from json file
-    graph = get_graph_from_json(graph_filename)
     # assign prices per products from json file
     prices = get_prices_from_json(prices_filename)
     # generate all the possible price configurations
Index: Progetto_Nuovo/Data/graph.json
===================================================================
diff --git a/Progetto_Nuovo/Data/graph.json b/Progetto_Nuovo/Data/graph.json
deleted file mode 100644
--- a/Progetto_Nuovo/Data/graph.json	(revision 738320252a715d0eaf18efc2c13aa63ffb0668ea)
+++ /dev/null	(revision 738320252a715d0eaf18efc2c13aa63ffb0668ea)
@@ -1,7 +0,0 @@
-{"edges": [
-  [[0.0, 0.25, 0.25, 0.25, 0.25],
-  [0.25, 0.0, 0.25, 0.25, 0.25],
-  [0.25, 0.25, 0.0, 0.25, 0.25],
-  [0.25, 0.25, 0.25, 0.0, 0.25],
-  [0.25, 0.25, 0.25, 0.25, 0.0]]
-}
\ No newline at end of file
Index: Progetto_Nuovo/Environment/ContextualEnvironment.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from Progetto_Nuovo.Social_Influence.SocialInfluence import *\n\n\nclass ContextualEnvironment:\n    def __init__(self, n_arms, lambda_coeff, n_prod):\n        self.n_arms = n_arms\n        self.customer_class = None\n        self.lambda_coeff = lambda_coeff\n        self.n_prod = n_prod\n\n\n    def round(self, configuration, prices, alpha_ratios, item_sold_mean):\n        prices_configuration = np.zeros(self.n_prod)\n        for product in range(self.n_prod):\n            prices_configuration[product] = prices[product][configuration[product]]\n        simulator = SocialInfluence(self.lambda_coeff, alpha_ratios, item_sold_mean, self.customer_class,\n                                    prices_configuration, self.n_prod, configuration)\n        simulator.simulation()\n        return simulator.reward, simulator.bought, simulator.actual_users\n\n    def select_costumer_class(self, customer_class):\n        self.customer_class = customer_class\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Progetto_Nuovo/Environment/ContextualEnvironment.py b/Progetto_Nuovo/Environment/ContextualEnvironment.py
--- a/Progetto_Nuovo/Environment/ContextualEnvironment.py	(revision 738320252a715d0eaf18efc2c13aa63ffb0668ea)
+++ b/Progetto_Nuovo/Environment/ContextualEnvironment.py	(date 1667558336290)
@@ -8,7 +8,6 @@
         self.lambda_coeff = lambda_coeff
         self.n_prod = n_prod
 
-
     def round(self, configuration, prices, alpha_ratios, item_sold_mean):
         prices_configuration = np.zeros(self.n_prod)
         for product in range(self.n_prod):
