# one campaign for each price configuration
import numpy as np
class PricingCampaign():
    def __init__(self, campaign_id, average_margin_for_configuration, configuration, margins_for_configuration):
        self.id = campaign_id
        # assign a random conversion rate between 1% and 20% for this campaign, TBD with Social Influence
        self.conversion_rate = np.random.uniform(0.01, 0.2, 3)
        # assign an amount of profit per successful sale for this campaign
        self.average_profit_per_sale = np.copy(average_margin_for_configuration)
        # track the number of successes and failures
        self.configuration = np.copy(configuration)
        self.sales = [0., 0., 0.]
        self.no_sales = [0., 0., 0.]
        # assign a random conversion rate between 1% and 20% for this campaign, for each price belonging to the price configuration
        self.conversion_rate_for_each_product = np.random.uniform(0.01, 0.2, (3, 5))
        # assign an amount of profit per successful sale for this campaign for each price belonging to the price configuration
        self.average_margin_for_price_in_configuration = np.copy(margins_for_configuration)
        self.global_history = [[] for i in range(3)]
        self.marginal_profit = [0., 0., 0.]
        self.aggregate_conversion_rate = 0
        self.aggregate_sales = 0
        self.aggregate_units_sold_per_product = [0, 0, 0, 0, 0]

    # a function that returns the total number of times this campaign has been tried
    def total_trials(self, customer_class):
        return self.sales[customer_class] + self.no_sales[customer_class]

    # a function that returns the total profit thus far generated by this campaign
    def total_profit(self, customer_class):
        return self.sales[customer_class] * self.average_profit_per_sale

    # a function that returns the actual amount of profit per trial
    def actual_profit_per_trial(self):
        if self.total_trials() > 0:
            return self.total_profit() / self.total_trials()
        else:
            return 0.

    # a function that returns the expected (theoretical) amount of profit per trial
    def expected_profit_per_trial(self, customer_class):
        return self.conversion_rate[customer_class] * self.average_profit_per_sale


# define a function to try an pricing campaign on a customer, TDB Social Inflence
def try_campaign(campaign, customer_class):
    if np.random.random() <= campaign.conversion_rate[customer_class]:
        campaign.sales[customer_class] += 1
    else:
        campaign.no_sales[customer_class] += 1


